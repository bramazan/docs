---
title: Mobile App Integration
description: Accept payments in iOS and Android mobile applications with secure native SDKs
icon: 'mobile'
---

# Mobile App Payment Integration

Build secure, native payment experiences for iOS and Android apps with simplified PCI compliance and optimized mobile flows.

## Overview

<CardGroup cols={2}>
  <Card title="Native SDKs" icon="mobile-screen-button">
    iOS and Android SDKs (coming soon)
  </Card>
  <Card title="Secure Input" icon="lock">
    PCI-compliant card collection
  </Card>
  <Card title="Biometric Auth" icon="fingerprint">
    Touch ID / Face ID support
  </Card>
  <Card title="Offline Mode" icon="wifi-slash">
    Queue payments when offline
  </Card>
</CardGroup>

## Current Implementation

While native SDKs are in development, you can integrate using our REST API:

### iOS Integration (Swift)

```swift
import Foundation

class OdealPaymentService {
    private let apiKey: String
    private let baseURL = "https://api.odeal.com/v1"
    
    init(apiKey: String) {
        self.apiKey = apiKey
    }
    
    func createPayment(
        amount: Decimal,
        currency: String,
        merchantId: String,
        orderId: String
    ) async throws -> Payment {
        let url = URL(string: "\(baseURL)/payments")!
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        
        let payload: [String: Any] = [
            "merchantId": merchantId,
            "amount": amount,
            "currency": currency,
            "orderId": orderId
        ]
        
        request.httpBody = try JSONSerialization.data(withJSONObject: payload)
        
        let (data, response) = try await URLSession.shared.data(for: request)
        
        guard let httpResponse = response as? HTTPURLResponse,
              httpResponse.statusCode == 200 else {
            throw PaymentError.requestFailed
        }
        
        let payment = try JSONDecoder().decode(Payment.self, from: data)
        return payment
    }
    
    func processPayment(
        paymentId: String,
        card: CardDetails
    ) async throws -> PaymentResult {
        let url = URL(string: "\(baseURL)/payments/\(paymentId)/process")!
        var request = URLRequest(url: url)
        request.httpMethod = "POST"
        request.setValue("Bearer \(apiKey)", forHTTPHeaderField: "Authorization")
        request.setValue("application/json", forHTTPHeaderField: "Content-Type")
        
        let payload: [String: Any] = [
            "card": [
                "number": card.number,
                "holderName": card.holderName,
                "expiryMonth": card.expiryMonth,
                "expiryYear": card.expiryYear,
                "cvv": card.cvv
            ]
        ]
        
        request.httpBody = try JSONSerialization.data(withJSONObject: payload)
        
        let (data, _) = try await URLSession.shared.data(for: request)
        let result = try JSONDecoder().decode(PaymentResult.self, from: data)
        
        return result
    }
}

// Usage in SwiftUI
struct CheckoutView: View {
    @State private var cardNumber = ""
    @State private var expiryDate = ""
    @State private var cvv = ""
    @State private var holderName = ""
    @State private var isProcessing = false
    
    let paymentService = OdealPaymentService(apiKey: "your-api-key")
    
    var body: some View {
        VStack(spacing: 20) {
            TextField("Card Number", text: $cardNumber)
                .keyboardType(.numberPad)
                .textContentType(.creditCardNumber)
            
            TextField("Cardholder Name", text: $holderName)
                .textContentType(.name)
            
            HStack {
                TextField("MM/YY", text: $expiryDate)
                    .frame(maxWidth: .infinity)
                
                SecureField("CVV", text: $cvv)
                    .frame(maxWidth: .infinity)
                    .keyboardType(.numberPad)
            }
            
            Button(action: processPayment) {
                if isProcessing {
                    ProgressView()
                } else {
                    Text("Pay Now")
                }
            }
            .buttonStyle(.borderedProminent)
            .disabled(isProcessing)
        }
        .padding()
    }
    
    func processPayment() {
        isProcessing = true
        
        Task {
            do {
                let payment = try await paymentService.createPayment(
                    amount: 100.00,
                    currency: "TRY",
                    merchantId: "your-merchant-id",
                    orderId: UUID().uuidString
                )
                
                let card = CardDetails(
                    number: cardNumber,
                    holderName: holderName,
                    expiryMonth: String(expiryDate.prefix(2)),
                    expiryYear: "20" + String(expiryDate.suffix(2)),
                    cvv: cvv
                )
                
                let result = try await paymentService.processPayment(
                    paymentId: payment.id,
                    card: card
                )
                
                if result.status == "SUCCEEDED" {
                    // Show success
                    showSuccessAlert()
                } else if result.status == "REQUIRES_3DS" {
                    // Open 3DS URL
                    open3DSChallenge(url: result.threeDSecureUrl)
                }
            } catch {
                showErrorAlert(error)
            }
            
            isProcessing = false
        }
    }
}
```

### Android Integration (Kotlin)

```kotlin
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import okhttp3.*
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.RequestBody.Companion.toRequestBody
import org.json.JSONObject

class OdealPaymentService(private val apiKey: String) {
    private val client = OkHttpClient()
    private val baseUrl = "https://api.odeal.com/v1"
    private val jsonMediaType = "application/json".toMediaType()
    
    suspend fun createPayment(
        amount: Double,
        currency: String,
        merchantId: String,
        orderId: String
    ): Payment = withContext(Dispatchers.IO) {
        val json = JSONObject().apply {
            put("merchantId", merchantId)
            put("amount", amount)
            put("currency", currency)
            put("orderId", orderId)
        }
        
        val request = Request.Builder()
            .url("$baseUrl/payments")
            .post(json.toString().toRequestBody(jsonMediaType))
            .header("Authorization", "Bearer $apiKey")
            .header("Content-Type", "application/json")
            .build()
        
        val response = client.newCall(request).execute()
        val responseJson = JSONObject(response.body?.string() ?: "")
        
        Payment(
            id = responseJson.getString("id"),
            amount = responseJson.getDouble("amount"),
            currency = responseJson.getString("currency"),
            status = responseJson.getString("status")
        )
    }
    
    suspend fun processPayment(
        paymentId: String,
        card: CardDetails
    ): PaymentResult = withContext(Dispatchers.IO) {
        val json = JSONObject().apply {
            put("card", JSONObject().apply {
                put("number", card.number)
                put("holderName", card.holderName)
                put("expiryMonth", card.expiryMonth)
                put("expiryYear", card.expiryYear)
                put("cvv", card.cvv)
            })
        }
        
        val request = Request.Builder()
            .url("$baseUrl/payments/$paymentId/process")
            .post(json.toString().toRequestBody(jsonMediaType))
            .header("Authorization", "Bearer $apiKey")
            .header("Content-Type", "application/json")
            .build()
        
        val response = client.newCall(request).execute()
        val responseJson = JSONObject(response.body?.string() ?: "")
        
        PaymentResult(
            status = responseJson.getString("status"),
            transactionId = responseJson.optString("transactionId"),
            threeDSecureUrl = responseJson.optString("threeDSecureUrl")
        )
    }
}

// Usage in Jetpack Compose
@Composable
fun CheckoutScreen() {
    var cardNumber by remember { mutableStateOf("") }
    var holderName by remember { mutableStateOf("") }
    var expiryDate by remember { mutableStateOf("") }
    var cvv by remember { mutableStateOf("") }
    var isProcessing by remember { mutableStateOf(false) }
    
    val scope = rememberCoroutineScope()
    val paymentService = remember { OdealPaymentService("your-api-key") }
    
    Column(
        modifier = Modifier
            .fillMaxSize()
            .padding(16.dp),
        verticalArrangement = Arrangement.spacedBy(16.dp)
    ) {
        OutlinedTextField(
            value = cardNumber,
            onValueChange = { cardNumber = it },
            label = { Text("Card Number") },
            keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),
            modifier = Modifier.fillMaxWidth()
        )
        
        OutlinedTextField(
            value = holderName,
            onValueChange = { holderName = it },
            label = { Text("Cardholder Name") },
            modifier = Modifier.fillMaxWidth()
        )
        
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.spacedBy(8.dp)
        ) {
            OutlinedTextField(
                value = expiryDate,
                onValueChange = { expiryDate = it },
                label = { Text("MM/YY") },
                modifier = Modifier.weight(1f)
            )
            
            OutlinedTextField(
                value = cvv,
                onValueChange = { cvv = it },
                label = { Text("CVV") },
                keyboardOptions = KeyboardOptions(keyboardType = KeyboardType.Number),
                visualTransformation = PasswordVisualTransformation(),
                modifier = Modifier.weight(1f)
            )
        }
        
        Button(
            onClick = {
                scope.launch {
                    processPayment(
                        paymentService,
                        cardNumber,
                        holderName,
                        expiryDate,
                        cvv
                    )
                }
            },
            enabled = !isProcessing,
            modifier = Modifier.fillMaxWidth()
        ) {
            if (isProcessing) {
                CircularProgressIndicator(
                    modifier = Modifier.size(24.dp),
                    color = Color.White
                )
            } else {
                Text("Pay Now")
            }
        }
    }
}
```

### React Native Integration

```javascript
import React, { useState } from 'react';
import { View, TextInput, Button, Alert } from 'react-native';

const ODEAL_API_KEY = 'your-api-key';
const ODEAL_BASE_URL = 'https://api.odeal.com/v1';

async function createPayment(amount, currency, merchantId, orderId) {
  const response = await fetch(`${ODEAL_BASE_URL}/payments`, {
    method: 'POST',
    headers: {
      'Authorization': `Bearer ${ODEAL_API_KEY}`,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      merchantId,
      amount,
      currency,
      orderId,
    }),
  });
  
  return await response.json();
}

async function processPayment(paymentId, cardDetails) {
  const response = await fetch(
    `${ODEAL_BASE_URL}/payments/${paymentId}/process`,
    {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${ODEAL_API_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        card: cardDetails,
      }),
    }
  );
  
  return await response.json();
}

export function CheckoutScreen() {
  const [cardNumber, setCardNumber] = useState('');
  const [holderName, setHolderName] = useState('');
  const [expiryDate, setExpiryDate] = useState('');
  const [cvv, setCvv] = useState('');
  const [isProcessing, setIsProcessing] = useState(false);
  
  const handlePayment = async () => {
    setIsProcessing(true);
    
    try {
      const payment = await createPayment(
        100.00,
        'TRY',
        'your-merchant-id',
        `order-${Date.now()}`
      );
      
      const result = await processPayment(payment.id, {
        number: cardNumber,
        holderName: holderName,
        expiryMonth: expiryDate.substring(0, 2),
        expiryYear: '20' + expiryDate.substring(3, 5),
        cvv: cvv,
      });
      
      if (result.status === 'SUCCEEDED') {
        Alert.alert('Success', 'Payment completed!');
      } else if (result.status === 'REQUIRES_3DS') {
        // Open 3DS URL in WebView
        navigation.navigate('3DS', { url: result.threeDSecureUrl });
      }
    } catch (error) {
      Alert.alert('Error', error.message);
    } finally {
      setIsProcessing(false);
    }
  };
  
  return (
    <View style={{ padding: 16 }}>
      <TextInput
        placeholder="Card Number"
        value={cardNumber}
        onChangeText={setCardNumber}
        keyboardType="numeric"
        textContentType="creditCardNumber"
      />
      
      <TextInput
        placeholder="Cardholder Name"
        value={holderName}
        onChangeText={setHolderName}
        textContentType="name"
      />
      
      <TextInput
        placeholder="MM/YY"
        value={expiryDate}
        onChangeText={setExpiryDate}
      />
      
      <TextInput
        placeholder="CVV"
        value={cvv}
        onChangeText={setCvv}
        keyboardType="numeric"
        secureTextEntry
      />
      
      <Button
        title={isProcessing ? 'Processing...' : 'Pay Now'}
        onPress={handlePayment}
        disabled={isProcessing}
      />
    </View>
  );
}
```

## Security Best Practices

<AccordionGroup>
  <Accordion title="Never Store Card Data">
    Always tokenize cards immediately - never persist raw card numbers:
    
    ```swift
    // ❌ NEVER DO THIS
    UserDefaults.standard.set(cardNumber, forKey: "card")
    
    // ✅ DO THIS
    let token = try await paymentService.tokenizeCard(card)
    secureStorage.save(token, forKey: "cardToken")
    ```
  </Accordion>
  
  <Accordion title="Certificate Pinning">
    Implement SSL pinning for API calls:
    
    ```kotlin
    val certificatePinner = CertificatePinner.Builder()
        .add("api.odeal.com", "sha256/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=")
        .build()
    
    val client = OkHttpClient.Builder()
        .certificatePinner(certificatePinner)
        .build()
    ```
  </Accordion>
  
  <Accordion title="Biometric Authentication">
    Require biometric auth for saved cards:
    
    ```swift
    import LocalAuthentication
    
    func authenticateForPayment() async throws -> Bool {
        let context = LAContext()
        var error: NSError?
        
        guard context.canEvaluatePolicy(.deviceOwnerAuthenticationWithBiometrics, error: &error) else {
            return false
        }
        
        return try await context.evaluatePolicy(
            .deviceOwnerAuthenticationWithBiometrics,
            localizedReason: "Authenticate to complete payment"
        )
    }
    ```
  </Accordion>
  
  <Accordion title="Secure Storage">
    Use Keychain (iOS) / Keystore (Android) for sensitive data:
    
    ```swift
    // iOS Keychain
    let query: [String: Any] = [
        kSecClass as String: kSecClassGenericPassword,
        kSecAttrAccount as String: "cardToken",
        kSecValueData as String: token.data(using: .utf8)!
    ]
    SecItemAdd(query as CFDictionary, nil)
    ```
  </Accordion>
</AccordionGroup>

## Offline Mode

Handle poor connectivity gracefully:

```javascript
import NetInfo from '@react-native-community/netinfo';

async function processPaymentWithRetry(payment, card) {
  const netInfo = await NetInfo.fetch();
  
  if (!netInfo.isConnected) {
    // Queue for later
    await queuePayment({ payment, card });
    throw new Error('No internet connection. Payment queued.');
  }
  
  try {
    return await processPayment(payment.id, card);
  } catch (error) {
    if (error.code === 'NETWORK_ERROR') {
      await queuePayment({ payment, card });
    }
    throw error;
  }
}

// Process queued payments when online
NetInfo.addEventListener(state => {
  if (state.isConnected) {
    processQueuedPayments();
  }
});
```

## Next Steps

<CardGroup cols={2}>
  <Card title="API Reference" icon="code" href="/api-reference/payments">
    Complete payment API documentation
  </Card>
  <Card title="3D Secure" icon="shield" href="/features/3ds-integration">
    Implement 3D Secure authentication
  </Card>
  <Card title="Testing" icon="flask" href="/guides/testing">
    Test mobile integrations
  </Card>
  <Card title="Security Guide" icon="lock" href="/guides/security">
    Security best practices
  </Card>
</CardGroup>
